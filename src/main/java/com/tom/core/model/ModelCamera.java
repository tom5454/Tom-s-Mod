// Date: 2015.11.11. 18:28:20
// Template version 1.1
// Java generated by Techne
// Keep in mind that you still need to fill in some blanks
// - ZeuX
package com.tom.core.model;

import com.tom.core.tileentity.TileEntityCamera;
import com.tom.lib.Configs;
import com.tom.model.IBaseModel;

import net.minecraft.client.model.ModelBase;
import net.minecraft.client.model.ModelRenderer;
import net.minecraft.entity.Entity;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.ResourceLocation;

public class ModelCamera extends ModelBase implements IBaseModel
{
  //fields
    ModelRenderer Cam;
  
  public ModelCamera()
  {
    textureWidth = 32;
    textureHeight = 32;
    
      Cam = new ModelRenderer(this, 0, 0);
      Cam.addBox(0F, 0F, 0F, 6, 6, 6);
      Cam.setRotationPoint(-3F, 13F, -3F);
      Cam.setTextureSize(32, 32);
      Cam.mirror = true;
      setRotation(Cam, 0F, 0F, 0F);
  }
  
  public void render(Entity entity, float f, float f1, float f2, float f3, float f4, float f5)
  {
    super.render(entity, f, f1, f2, f3, f4, f5);
    setRotationAngles(f, f1, f2, f3, f4, f5,entity);
    Cam.render(f5);
  }
  
  private void setRotation(ModelRenderer model, float x, float y, float z)
  {
    model.rotateAngleX = x;
    model.rotateAngleY = y;
    model.rotateAngleZ = z;
  }
  
  public void setRotationAngles(float f, float f1, float f2, float f3, float f4, float f5,Entity ent)
  {
    super.setRotationAngles(f, f1, f2, f3, f4, f5,ent);
    //this.Cam.rotateAngleX = f4 / (180F / (float)Math.PI);
    //this.Cam.rotateAngleY = f3 / (180F / (float)Math.PI);
  }

@Override
public void renderStatic(float size, TileEntity te) {
	if(te != null && te instanceof TileEntityCamera){
		//TileEntityCamera t = (TileEntityCamera) te;
		//Tessellator tessellator = Tessellator.instance;
		//Cam.rotateAngleX = t.yaw / (180F / (float)Math.PI);
		//Cam.rotateAngleY = t.pitch / (180F / (float)Math.PI);
		//GL11.glPushMatrix();
		//GL11.glTranslatef(0.5F, 1.5F, 0.5F);
		//GL11.glRotatef(t.pitch, 1F, 0F, 0F);
		//GL11.glRotatef(t.yaw + 90F, 0F, 1F, 0F);
		//GL11.glTranslatef(0F, -1F, 0F);
		//GL11.glTranslatef(0F, 1F, 0F);
		//GL11.glTranslated(+0.09375D, 1.4D, 1D);
		//GL11.glTranslated(-1D, 0, 0.0D);
		//GL11.glRotatef(rotateAngleX,0,0, -1.0F);
		//GL11.glRotatef(rotateAngleY,0,1.0F,0);
		//GL11.glTranslated(t.yaw/3F/100F, 0.0, 0.405F);
		//this.setRotationAngles(0, 0, 0,t.yaw, t.pitch, 0.0625F, null);
		Cam.render(size);
		//GL11.glPopMatrix();
	}else{
		Cam.render(size);
	}
	
}

@Override
public void renderDynamic(float size, TileEntity te, float partialTicks) {
}

@Override
public ResourceLocation getModelTexture(TileEntity tile) {
	return Configs.cam;
}

@Override
public boolean rotateModelBasedOnBlockMeta() {
	return true;
}

}
